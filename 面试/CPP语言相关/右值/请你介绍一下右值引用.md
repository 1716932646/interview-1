# 右值引用
C++ 中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。

而在指C++11中，右值是由两个概念构成，==将亡值==和==纯右值==。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等。

C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：


```
T && a=ReturnRvale();
```


假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding）（完美转发）这两新特性，它的主要目的有两个方面：

* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
* 能够更简洁明确地定义泛型函数。


# 移动语义：

对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。

但是如下列代码所示：

```c++
#include <iostream>
using namespace std;

class HasPtrMem{
public:
    HasPtrMem(): d(new int(0)){
    cout<<"Construct: "<<++n_cstr<<endl;
    }
    
    HasPtrMem(const HasPtrMem & h): d(new int(*h.d)) {
        cout<<"Copy construct: "<< ++n_cptr <<endl;
    }
    
    ~HasPtrMem(){
        cout<<"Destruct: "<<++n_dstr<<endl;
    }
    
    int * d;
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
};

int HasPtrMem::n_cstr=0;
int HasPtrMem::n_dstr=0;
int HasPtrMem::n_cptr=0;

HasPtrMem GetTemp(){ return HasPtrMem();}

int main(){
    HasPtrMem a = GetTemp();
}
```
当类HasPtrMem包含一个成员函数GetTemp,其返回值类型是HasPtrMem,如果我们定义了深拷贝的拷贝构造函数，那么在调用该函数时需要调用两次拷贝构造函数。第一次是生成GetTemp函数返回时的临时变量，第二次是将该返回值赋值给main函数中的变量a。与此对应需要调用三次析构函数来释放内存。

而在上述过程中，使用临时变量构造a时会调用拷贝构造函数分配对内存，而临时对象在语句结束后会释放它所使用的堆内存。这样重复申请和释放内存，在申请内存较大时会严重影响性能。因此C++使用移动构造函数，从而保证使用临时对象构造a时不分配内存，从而提高性能。

如下列代码所示，移动构造函数接收一个右值引用作为参数，使用右值引用的参数初始化其指针成员变量。

```c++
HasPtrMem(HasPtrMem && h): d(h.d){//移动构造函数
    h.d = nullptr;
    cout<<"Move construct: "<<++n_mvtr<<endl;
}

```
其原理就是使用在构造对象a时，使用h.d来初始化a，然后将临时对象h的成员变量d指向nullptr，从而保证临时变量析构时不会释放对内存。

# 完美转发：

完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销。

因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型。

C++通过引入一条所谓“引用折叠”的语言规则，并结合模板推导来完成完美转发的。
首先看一个例子：


```c++
template<typename T>
void testFunc(T& r)
{
	
}
```


当我们给函数传入引用时，如果我们对函数 testFunc 传入一个非引用类型的数据，那么形参中r的类型时什么呢？传入一个右值引用，形参r中的类型是什么呢？如果函数参数声明的类型是右值引用，传入左值引用结果又会怎样呢？

模板对类型的推到规则和简单，当转发函数的实参是类型T的左值引用,那么模板参数被推导为T&类型；如果转发函数的实参是类型T的右值引用，那么模板参数被推导为T&&类型。
具体引用折叠可以参照下表：

#### 引用折叠
| 函数参数声明的类型 | 传入实参的类型 | r的类型 |
| ------------------ | -------------- | ------- |
| T&                 | TR             | r&      |
| T&                 | TR&            | r&      |
| T&                 | TR&&           | r&      |
| T&&                | TR             | r&&     |
| T&&                | TR&            | r&      |
| T&&                | TR&&           | r&&     |


* `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`
* `X&& &&` 可折叠成 `X&&`

从上表可以看出无论传入什么类型，右值引用都可以保持跟出入的实参类型保持不变。
所以，我们可以这么写完美转发的模板：


```c++
template<typename T>
void perfectForward(T&& t)
{
	func(std::forward<T>(t));
}

```
* 当传入的为一个const T类型实参时，如果不适用右值引用，则需要声明一个const T的函数版本，因为const T&无法转换为T&，由于使用的右值引用我们就可以完全不用声明带有const版本的转发函数。
* 使用std::forward是为了保证函数可以调用正确形参形式的函数。
下面是一个不带std::forward的示例：

```c++
#include <iostream>
#include <stdlib.h>
#include <type_traits>

void func(int& t)
{
	std::cout << "func(int& t)" << std::endl;
}

void func(const int& t)
{
	std::cout << "func(const int& t)" << std::endl;
}

void func(const int&& t)
{
	std::cout << "func(const int&& t)" << std::endl;
}

template<typename T>
void perfectForward(T&& t)
{
	//func(std::forward<T>(t));
	func(t);
}

int main(int argc, char** argv)
{
	int a = 0;
	perfectForward(a);

	const int b = 20;
	perfectForward(b);

	perfectForward(std::move(a));

	system("pause");
	return 0;
}


```
函数的运行结果为：

```
func(int& t)
func(const int& t)
func(int& t)
```
但是我们想让调用函数 `perfectForward(10)`; 的时候调用函数 `void func(const int&& t)` 因为`std::move(a)`是一个右值引用。而由于引用折叠的作用，当传入一个右值到形参 T& 中会被认为推导为左值。因此，需要是使用`std::forward`，`std::forward`的作用就是==强制转化为实际类型的值作为形参==。
更改为std::forward 后，运行效果为：

```
func(int& t)
func(const int& t)
func(const int&& t)
```

