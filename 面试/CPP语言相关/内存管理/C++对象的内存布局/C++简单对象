在一个C++对象中包含**成员数据**和**成员函数**，成员数据分为静态成员数据和非静态成员数据；成员函数分为静态成员函数、非静态成员函数和虚函数。

```c++
#include <stdio.h>
#include <stdlib.h>

class SimpleObject
{
public:
    //静态成员数据nCounter存储在全局/静态数据区，由类的所有对象共享，并不作为对象占据的内存的一部分，因此sizeof返回的SimpleObject大小并不包括nCounter所占据的内存大小。
    static int nCounter;
    
    //非静态成员数据value和flag存储在对象占用的内存中，不论是全局/静态数据区，还是堆上、栈上。
    //Value是double类型，占据8个字节（64位）
    double value;
    //flag是char类型，占据1个字节，但由于内存对齐，也会占用8字节。
    char flag;
    SimpleObject()
    {
        printf("SimpleObject Created\n");
    }
    virtual ~SimpleObject()
    {
        printf("SimpleObject Destroyed\n");
    }

    double getValue()
    {
        return value;
    }
    static int getCount()
    {
        return nCounter;
    }
    virtual void test()
    {
        printf("virtual void test()\n");
    }
};

```

```c++
printf("Object size: %d\n", sizeof(object)); // Object size: 24
```

SimpleObject类对象的数据成员占用了16个字节，剩下的8字节是与虚函数相关的。如果将两个虚函数的virtual关键字去掉，则sizeof（SimpleObject）将得到16。



虚函数用于实现C++语言的动态绑定特性，为了实现动态绑定特性，C++编译器遇到含有虚函数的类时，**会分配一个指针指向一个函数地址表**，即虚函数表（virtual table），虚函数表**指针**占据了8个字节，**并且占据的是类实例内存布局开始的8个字节**。





C++简单对象占用的内存空间如下：
（1）非静态成员数据是影响对象占用内存大小的主要因素，随着对象数目的增加，非静态成员数据占用的内存空间会相应增加。
（2）所有的对象共享一份静态成员数据，因此静态成员数据占用的内存空间大小不会随着对象数目的增加而增加。
（3）静态成员函数和非静态成员函数不会影响对象内存的大小，虽然其实现会占用相应的内存空间，同样不会随着对象数目的增加而增加。
（4）如果类中包含虚函数，类对象会包含一个指向虚函数表的指针，虚函数的地址会放在虚函数表中。

在虚函数表中，不一定完全是指向虚函数实现的指针。当指定编译器打开RTTI(Run Time Type Identification)开关时，先讲讲RTTI这一机制，和很多其他语言一样，C++是一种**静态类型语言**。其**数据类型是在编译期就确定的**，不能在运行时更改。然而由于**面向对象程序设计中多态性**的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。



来看看狗日的Java是怎么做的：

Java中任何一个类都可以通过**反射**机制来获取类的基本信息（接口、父类、方法、属性、Annotation等）

和Java相比，C++要想获得运行时类型信息，只能通过RTTI机制。



RTTI提供了两个非常有用的操作符：typeid和dynamic_cast。



当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用**运行时类型标识**做出。为了获得一个对象的类型可以使用`typeid`函数，该函数反回一个对`type_info`类对象的引用，要使用`typeid`必须使用头文件`<typeinfo>`.

来看一下type_info类

```c++
class type_info {  
public:  
        //析构函数  
    _CRTIMP virtual ~type_info();  
    //重载的==操作符  
    _CRTIMP int operator==(const type_info& rhs) const;  
    //重载的!=操作符  
    _CRTIMP int operator!=(const type_info& rhs) const;  
    _CRTIMP int before(const type_info& rhs) const;//用于type_info对象之间的排序算法  
    //返回类的名字  
    _CRTIMP const char* name() const;  
    _CRTIMP const char* raw_name() const;//返回类名称的编码字符串  
private:  
    //各种存储数据成员  
    void *_m_data;  
    char _m_d_name[1];  
    //将拷贝构造函数与赋值构造函数设为了私有  
    type_info(const type_info& rhs);  
    type_info& operator=(const type_info& rhs);  
};
```

因为type_info类的复制构造函数和赋值运算符都是私有的，所以不允许用户自已创建type_info的类。唯一要使用type_info类的方法就是使用typeid函数。





### typeid函数

typeid函数的主要作用就是让用户知道当前的变量是什么类型的，比如使用typeid(a).name()就能知道变量a是什么类型的。typeid()函数的返回类型为type_info类型的引用。

typeid() 返回type_info类型对象引用，但不允许创建type_info类，那是这个类哪来的呢？

这可能是把typid函数声明为了type_info类的**友元函数**来实现的，默认构造函数并不能阻止该类的友元函数创建该类的对象。所以typeid函数如果是友元的话就可以访问type_info类的私有成员，从而可以创建type_info类的对象，从而可以创建返回类型为type_info类的引用。





### dynamic_cast强制转换运算符

该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用，注意**dynamic_cast转换符只能用于含有虚函数的类**。

