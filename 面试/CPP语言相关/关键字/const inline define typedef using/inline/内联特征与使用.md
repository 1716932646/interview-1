# inline 内联函数特征

* 相当于把内联函数里面的内容写在调用内联函数处；
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

# inline 使用

```c++
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```
# 编译器对 inline 函数的处理步骤
1. 将 inline 函数体复制到 inline 函数调用点处； 
2. 为所用 inline 函数中的局部变量分配内存空间； 
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。



内联函数一般可以：

1. 加快程序的执行速度；

2. 可能减小可执行文件的大小；

3. 可能增加可执行文件的大小；

4. 可能降低执行速度。

1和3很好理解，在编译时期内联函数能将代码直接写入其被调用的地方，这样就减少了入栈出栈的时间消耗，但是如果调用内联函数的地方过多，**代码量也会随之增加，增加了可执行文件的大小。**

2为什么正确呢？是因为如果调用普通函数的话编译器可能会产生更多的代码来实现压、出寄存器的代码，对于简单的内联函数会这样。但如果优化器能顺序集成消除大量冗余代码的话，对大函数也同样适用。

4呢？**如果可执行文件过大，会频繁的出现内存的换入换出操作，会使执行速度下降。**
