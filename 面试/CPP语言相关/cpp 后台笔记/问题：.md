问题：

1. 进程线程之间有什么区别

2. 进程与线程各有什么特点

3. 进程之间是怎么进行交互的

4. 线程之间是如何进行交互的

5. 什么是缓冲区溢出



进程是系统资源分配和调度的基本单位，（程序的实体是线程的容器，系统中在运行的一个应用程序）

线程是系统能够进行运算的最小单位（在一个进程中能够并发多个线程）



进程：

内存：

逻辑内存（每个进程的内有空间都是独立的，指的是内存的寻址空间）



文件/网络句柄：

1. 进程不能共用一个内存

2. 但是可以打开同一个文件或者访问同一个网络端口



线程1 、线程2、。。。线程n

栈：调用（从主函数入口不断调用函数，将参数和返回地址压入栈中）

PC（program counter 程序计数器）： 操作系统真正运行的是一个一个的线程，PC指向的是当前的指令

每个线程都有自己的指针，指向当前所在的内存

缓冲区溢出：本来存储数据的区域由于输入过多，溢出到程序的内存去，覆盖代码



TLS（thread local storage 线程本地存储）：每个进程具有自己独立的内存







进程之间通过TCP/IP的端口来实现交互

线程之间的交互：线程有一块大的共享内存，只要指针相同，就可以看见各自的内容

1. 进程分配一大部分的内存，而线程只需要一部分栈

2. 一个程序至少有一个进程，一个进程至少有一个线程

3. 进程是资源分配的基本单位，线程是程序执行的最小单位

4. 一个线程可以创建和撤销另一个线程，同一个进程中多个线程可以并发执行



进程之间的通信方式：



1. 管道：

半双工

父子进程之间

调用pipe建立管道后调用fork（）建立与子进程之间的连接

使用的是共享的内核缓冲区，因为子进程与父进程具有相同的文件描述符



2.命名管道（FIFO）

半双工

可以在无关进程之间通信

先进先出



3. 消息队列

消息队列具有特定格式和优先级

进程终止，消息队列不会小时，不一定要先进先出，可以按类型 

通过类型type

type==0 返回第一个

type>0 返回该类型

type<0 返回值小于|type|的第一个



4.信号量：

计数器，用于实现进程之间的互相同步，不存储数据



5.共享内存：

两个或多个进程共享一个存储区（信号量同步）



6.socket通信：

用于两个不再本地的进程间5通信：

标识： IP+TCP/UDP+端口



server：socket() bind() listen() accept()

client：socket() connect()



7.信号：kill 命令可以发送信号，处理方式类似软中断







c++中的线程同步及互斥：

1. 同步： 一条线程只有等待另一个线程的某个消息才能继续执行，否则就被阻塞，称为同步

2. 互斥： 多个线程对共享资源进行操作，防止同时对共享资源进行修改



Win32中主要有以下机制：

1. 事件 EVENT

2. 信号量 semaphone

3. 互斥量 mutex

4. 临界区 Critical section



1. 临界区

在访问同一个共享资源时，线程需要进入临界区，而每一个时刻只能有一个线程在临界区，其它试图进入临界区的线程将会被挂起直到临界区中没有线程



c++用 CRITICLA_SECTION结构创建临界区



在线程中用EnterCriticalSection（创建的临界区对象）函数进入临界区

中间的代码为用户对共享对象的操作

用LeaveCriticalSection()离开



2.事件

手动设置：需要在设置该事件或事件发生时使用 setEVENT 或者 getEVNET

自动恢复：一旦事件发生并被处理，自动恢复到没有事件的状态，不需要再次设置

线程中用 waitForSingleObject（事件名，INFINITE）来确定事件是否触发，若事件触发则处理下面的代码，否则就被阻塞在这里





waitForSingleObject（事件名，INFINITE）   <==等待时间发生

。。。代码。。。事件触发（自动恢复到没有事件的状态并执行代码）

==结束后可以用setEVENT（事件名）再次触发事件



3. 信号量

信号量是维护一个0到最大值之间的同步对象

1.  若当前资源数量大于0（信号量大于0）则信号量有效

2. =0，则信号量无效

3. 信号量不会变为负

4. 当前信号量不能超过设置的最大值

C++中用CreateSemaphore（安全属性，开始可供使用资源数，最大资源数，信号量名称）来创建一个信号量



安全属性默认NULL



4. 互斥量

值有拥有互斥对象的线程才能访问公共资源，互斥对象只有一个，能保证资源不被多个线程访问



（操作系统单独学！！！）





