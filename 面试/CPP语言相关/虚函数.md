# 分别简单介绍一下c++中的 虚函数 纯虚函数 虚基类 虚继承

虚函数 ，纯虚函数， 虚基类，它们都和virtual有关，这三个带有虚字的定义容易使人混淆，下面先从作用上来解释这三个定义的区别：

1. 虚函数是用于多态中virtual修饰父类函数，确保父类指针调用子类对象时，运行子类函数的。

2. 纯虚函数是用来定义接口的，也就是基类中定义一个纯虚函数，基类不用实现，让子类来实现。

3. 虚基类是用来在多继承中，如果父类继承自同一个父类，就只实例化一个父类(说的有点绕，就是只实例化一个爷爷的意思。

4. 虚继承

虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

# 虚继承、虚函数

* 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
* 不同之处：
  * 虚继承
    * 虚基类依旧存在继承类中，只占用存储空间
    * 虚基类表存储的是虚基类相对直接继承类的偏移
  * 虚函数
    * 虚函数不占用存储空间
    * 虚函数表存储的是虚函数地址

# 虚函数、纯虚函数

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。

2. 虚函数可以被直接使用，也可以被子类重载以后以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类只有声明而没有定义。

3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。

4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。

5. 虚函数的定义形式：virtual {method body}

　纯虚函数的定义形式：virtual { } = 0;

在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

6. 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。

7. 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

8. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。

9. 虚函数是C++中用于实现多态的机制。核心理念就是通过基类访问派生类定义的函数

10. 多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。

a.编译时多态性：通过重载函数实现
b 运行时多态性：通过虚函数实现。
11. 如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类(ABC)是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法

# 抽象类、接口类、聚合类

* 抽象类：含有纯虚函数的类
* 接口类：仅含有纯虚函数的抽象类
* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
  * 所有成员都是 public
  * 没有定义任何构造函数
  * 没有类内初始化
  * 没有基类，也没有 virtual 函数

# 模板类、成员模板、虚函数

* 模板类中可以使用虚函数
* 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数


# 虚函数指针、虚函数表

* 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
* 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构]，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

##### 目标文件存储结构

| 段                      | 功能                                                         |
| ----------------------- | ------------------------------------------------------------ |
| File Header             | 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） |
| .text section           | 代码段，执行语句编译成的机器代码                             |
| .data section           | 数据段，已初始化的全局变量和局部静态变量                     |
| .bss section            | BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） |
| .rodata section         | 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 |
| .comment section        | 注释信息段，存放编译器版本信息                               |
| .note.GNU-stack section | 堆栈提示段                                                   |

# C++虚基类的作用、用法和意义

如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员。这种现象是人们不希望出现的。C++提供虚基类(virtual base class)的方法，使得在继承间接共同基类时只保留一份成员。虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。因为一个基类可以在生成一个派生类时作为虚基类，而在生成另一个派生类时不作为虚基类。
# 虚函数实现机制
1、当类中存在虚函数，则编译器会在编译期自动的给该类生成一个函数表，并在所有该类的对像中放入一个隐式变量vptr,该变量是一个指针变量，它的值指向那个类中的由编译器生成的虚函数表.

2、每个类自己的虚函数入口都在这张表中维护，调用方法的时候会隐式的传入一个this指针，然后系统会根据this指针找到对应的vptr,进而找到对应的虚函数表，找到真正方法的地址，然后才去调用这个方法，这可以叫动态绑定。

3、虚函数表存放重写的虚函数，当基类的指针指向派生类的对象时，调用虚函数时都会根据vptr来选择虚函数，而基类的虚函数在派生类里已经被改写或者说已经不存在了，所以也就只能调用派生类的虚函数版本了.

# 哪些函数不能定义为虚函数？
经检验下面的几个函数都不能定义为虚函数：

1）友元函数，它不是类的成员函数

2）全局函数

3）静态成员函数，它没有this指针

4）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

# 构造函数不能声明为虚函数的原因是:

* 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。
* 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。



# 请你说说虚函数表具体是怎样实现运行时多态的?
参考回答1：
子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。

答2：基类的指针指向子类的对象，子类对象重写了基类中的虚函数，那么在用基类指针操作该函数时就会根据其指向对象的类型（基类还是子类）分别调用不同的函数。

这是通过虚函数表实现的。只要类定义中含有虚函数声明，那么编译器就会为该类建立对应的虚函数表，按照虚函数声明顺序将函数入口地址保存在虚函数表中，这个表不占用对象内存，但是编译器会为对象分配一个指向虚函数表地址的指针vptr，在对象中占有一个指针大小的内存。子类重写的虚函数的地址直接替换了父类虚函数在虚函数表中的位置，而子类中独有的虚函数在其虚函数表中会依次排在从父类继承的虚函数后面。

在实际调用函数时，编译器先检查该函数是否为虚函数，如果是，则在对象的虚函数表中找到函数入口地址进行调用。对于在子类总重写的虚函数，这样就实现了多态。

# 请你回答一下静态函数和虚函数的区别
静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

# 请你说一说重载和覆盖
重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

# 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C ++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

# 析构函数什么情况下要定义为虚函数

答：析构函数的作用与构造函数正好相反，是在对象的生命期结束时，释放系统为对象所分配的空间，即要撤消一个对象。

用对象指针来调用一个函数，有以下两种情况： 
1.如果是虚函数，会调用派生类中的版本。（在有派生类的情况下） 
2.如果是非虚函数，会调用指针所指类型的实现版本。

析构函数也会遵循以上两种情况，因为析构函数也是函数嘛，不要把它看得太特殊。 当对象出了作用域或是我们删除对象指针，析构函数就会被调用。 
1.当派生类对象出了作用域，派生类的析构函数会先调用，然后再调用它父类的析构函数， 这样能保证分配给对象的内存得到正确释放。 
2.但是，如果我们删除一个指向派生类对象的基类指针，而基类析构函数又是非虚的话， 那么就会先调用基类的析构函数(上面第2种情况)，派生类的析构函数得不到调用，造成内存泄露。


# 请你说一说你理解的虚函数和多态
多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。

举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。

虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

# 给你一个类，里面有virtual，来说一说这个类的内存分布
C++继承和虚函数

C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

动态多态实现有几个条件：

(1) 虚函数；

(2) 一个基类的指针或引用指向派生类的对象；

基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。

每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。

虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。

3、virtual修饰符

如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。

如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。

如果类中成员是virtual属性，会隐藏父类对应的属性。
![image](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA)