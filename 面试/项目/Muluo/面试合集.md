## 面试题
包括项目介绍，线程池相关，并发模型相关，HTTP报文解析相关，定时器相关，日志相关，压测相关，综合能力等。

### 项目介绍
* 为什么要做这样一个项目？
 简单，服务器开发需要一个BS 和 一个 CS，这个项目看了游双的教程自然想到做。

* 介绍下你的项目
——Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.使用线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型；使用状态机解析HTTP请求报文，支持解析GET和POST请求；访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件；实现同步/异步日志系统，记录服务器运行状态；经Webbench压力测试可以实现上万的并发连接数据交换；



### 并发模型相关
* 简单说一下服务器使用的并发模型？

——该项目选用的半同步半反应堆的并发模型。以Proactor模式为例的工作流程即是：主线程充当异步线程，负责监听所有socket上的事件若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

* reactor、proactor、主从reactor模型的区别？
    * Reactor模式：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程，将socket可读可写事件放入请求队列，**读写数据、接受新连接及处理客户请求均在工作线程中完成。(需要区别读和写事件)**
    * Proactor模式：主线程和内核负责处理读写数据、接受新连接等**I/O操作，工作线程仅负责业务逻辑（给予相应的返回url）**，如处理客户请求。
    * 主从Reactor模式：核心思想是，主反应堆线程只负责分发Acceptor连接建立，已连接套接字上的I/O事件交给sub-reactor负责分发。其中 sub-reactor的数量，可以根据CPU的核数来灵活设置。下图即是其工作流程：
    ![image](https://pic2.zhimg.com/v2-9e07d2da99253d5330fac1c953521791_b.jpg)
    **主反应堆线程一直在感知连接建立的事件**，如果有连接成功建立，主反应堆线程通过accept方法获取已连接套接字，**接下来会按照一定的算法选取一个从反应堆线程**，并把已连接套接字**加入到选择好的从反应堆线程中**。主反应堆线程唯一的工作，就是调用accept获取已连接套接字，以及将已连接套接字加入到从反应堆线程中。


* 你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？


——先说说其他的复用方式吧，比较常用的有三种：select/poll/epoll。本项目之所以采用epoll，[参考问题（Why is epoll faster than select?）](https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select)



* 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，**每次调用都需要将整个集合拷贝到内核态**；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要**执行一个系统调用**。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。

* select使用线性表描述文件描述符集合，**文件描述符有上限**；poll使用**链表来描述**；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。
* select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，**它们会采用遍历的方式**，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，**会自动触发epoll回调函数通知epoll文件描述符**，然后内核将这些就绪的文件描述符放到之前提到的**ready list中等待epoll_wait调用后被处理**。
* select和poll都只能工作在**相对低效的LT模式**下，而epoll同时支持LT和ET模式。
* 综上，**当监测的fd数量较小**，且各个fd都很活跃的情况下，建议使用select和poll；**当监听的fd数量较多**，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。

### HTTP报文解析相关
* 用了状态机啊，为什么要用状态机？

——有限状态机，是一种抽象的理论模型，它能够把有限个变量描述的状态变化过程，以可构造可验证的方式呈现出来。比如，封闭的有向图。有限状态机可以通过if-else,switch-case和函数指针来实现，从软件工程的角度看，主要是为了封装逻辑。有限状态机一种逻辑单元内部的一种高效编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂。

* 状态机的转移图画一下
![image](https://mmbiz.qpic.cn/mmbiz_jpg/6OkibcrXVmBH2ZO50WrURwTiaNKTH7tCia3AR4WeKu2EEzSgKibXzG4oa4WaPfGutwBqCJtemia3rc5V1wupvOLFjzQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
* https协议为什么安全？
——连接建立阶段基于ssl安全验证；数据传输阶段加密，
* https的ssl连接过程
——一张图就够了：
![image](https://pic2.zhimg.com/v2-e03691ec1b4cec38f18360dcc4b2e7ad_b.jpg)
* GET和POST的区别
https://www.cnblogs.com/logsharing/p/8448446.html

### 数据库登录注册相关
* 登录说一下？
具体的涉及到**载入数据库表，提取用户名和密码，注册登录流程与页面跳转**。
    * 载入数据库表，结合代码将数据库中的数据载入到服务器中；
    * 提取用户名和密码，结合代码对报文进行解析，提取用户名和密码；
    * 注册登录流程，结合代码对描述服务器进行注册和登录校验的流程；
    * 页面跳转，结合代码对页面跳转机制进行详解

* 你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）

——可以利用session或者cookie的方式进行状态的保存。cookie其实就是服务器给客户分配了一串“身份标识”，比如“123456789happy”这么一串字符串。每次客户发送数据时，都在HTTP报文附带上这个字符串，服务器就知道你是谁了；session是保存在服务器端的状态，每当一个客户发送HTTP报文过来的时候，服务器会在自己记录的用户数据中去找，类似于核对名单；


* 登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？
——这个问题的关键在于大数据量情况下的用户登录验证怎么进行？将所有的用户信息加载到内存中耗时耗利，对于大数据最遍历的方法就是**进行hash，利用hash建立多级索引的方式来加快用户验证**。

具体操作如下：
首先，将10亿的用户信息，利用大致缩小1000倍的hash算法进行hash，这时就获得了100万的hash数据，每一个hash数据代表着一个**用户信息块**（一级）；

而后，再分别对这100万的hash数据再进行hash，例如最终剩下1000个**hash数据**（二级）。

在这种方式下，服务器只需要保存1000个二级hash数据，当用户请求登录的时候，先对用户信息进行一次hash，找到对应信息块（二级），在读取其对应的一级信息块，最终找到对应的用户数据，

* 用的mysql啊，redis了解吗？用过吗？
用过https://www.zhihu.com/column/c_1358779780431659008

### 定时器相关
* 为什么要用定时器？
——处理定时任务，或者非活跃连接，节省系统资源；
* 说一下定时器的工作原理

——服务器就为各事件分配一个定时器。该项目使用SIGALRM信号来实现定时器，首先每一个定时事件都处于一个升序链表上，**通过alarm()函数周期性触发SIGALRM信号**，而后信号回调函数利用管道通知主循环，主循环接收到信号之后对升序链表上的定时器进行处理：若一定时间内无数据交换则关闭连接。


* 双向链表啊，删除和添加的时间复杂度说一下？还可以优化吗？
——添加一般情况下都是O(N)，删除只需要O(1)。从双向链表的方式优化不太现实，可以考虑使用最小堆、或者跳表的数据结构，https://zhuanlan.zhihu.com/p/360087451

* 最小堆优化？说一下时间复杂度和工作原理
——最小堆以每个定时器的过期时间进行排序，最小的定时器位于堆顶，当SIGALRM信号触发tick（）函数时执行过期定时器清除，如果堆顶的定时器时间过期，则删除，并重新建堆，再判定是否过期，如此循环直到未过期为止。

插入，O(logn)；
删除，O(logN)；



### 综合能力
* 你的项目解决了哪些其他同类项目没有解决的问题？
——自己造轮子；
* 说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？
——HTTP协议、TCP、IP协议等，计算机网络的知识。