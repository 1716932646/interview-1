#### 为什么要引入虚拟内存？

1. 虚拟内存作为缓存的工具
* 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。
* 虚拟内存利用DRAM缓存来自通常更大的虚拟地址空间的页面。

2. 虚拟内存作为内存管理的工具。操作系统为每个进程提供了一个独立的页表，也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个物理页面上。
  * **简化链接**： 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。
    * 例如：一个给定的 linux 系统上的每个进程都是用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址） 0x400000 开始，数据段，代码段，栈，堆等等。
  * **简化加载**： 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们**标记为无效（未被缓存）** ，将页表条目指向目标文件的起始位置。
    * **加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。**
  * **简化共享**： 独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。
    * 一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，**这样OS创建页表，将虚拟页映射到不连续的物理页面。**
    * 某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，
      或者C标准库函数。**OS会把不同进程中适当的虚拟页面映射到相同的物理页面。**
  * **简化内存分配**： 虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如 malloc ），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，**因此操作系统没有必要分配k个连**
    **续的物理内存页面，页面可以随机的分散在物理内存中**。
3. 虚拟内存作为内存保护的工具。不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时， MMU 会读一个 PTE ，通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。