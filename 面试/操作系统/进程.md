# 请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞
1、进程的五种基本状态：
![image](https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F)
1）创建状态：进程正在被创建

2）就绪状态：进程被加入到就绪队列中等待CPU调度运行

3）执行状态：进程正在被运行

4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。

5）终止状态：进程运行完毕

2、交换技术


当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。


针对以上问题，提出了两种解决方法：

1）交换技术：换出一部分进程到外存，腾出内存空间。

2）虚拟存储技术：每个进程只能装入一部分程序和数据。


在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。


从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。


3、活动阻塞，静止阻塞，活动就绪，静止就绪

1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。

2）静止阻塞：进程在外存，同时被某种原因阻塞了。

3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。

4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。


从而出现了：

活动就绪 ——  静止就绪        （内存不够，调到外存）

活动阻塞 ——  静止阻塞        （内存不够，调到外存）

执行     ——  静止就绪         （时间片用完）

# 请问就绪状态的进程在等待什么？
被调度使用cpu的运行权

# 进程同步与互斥
#### 同步

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。

#### 互斥

互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。

例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。

**为禁止两个进程同时进入临界区，同步机制应遵循以下准则：**

* 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
* 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
* 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。
* 让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。



# 请你说一下僵尸进程
1）正常进程
正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：

1进程号the process ID

2退出状态the termination status of the process

3运行时间the amount of CPU time taken by the process等

2）孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

3）僵尸进程

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。

如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。

如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

危害：

如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

外部消灭：

通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源

内部解决：

1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。

2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。


# 进程间调度算法
调度算法是指：根据系统的资源分配策略所规定的资源分配算法

### 先来先服务调度算法

 先来先服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。

### 时间片轮转调度算法

时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。

### 短作业(SJF)优先调度算法

 短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

### 最短剩余时间优先

 最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。

# 进程的通讯方式

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。
### 管道
1. 无名管道(普通管道)(PIPE)，是 UNIX 系统IPC最古老的形式。


    1. 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
    
    2. 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
    
    3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中


* 优点：简单方便
* 缺点：
  1. 局限于单向通信 
  2. 只能创建在它的进程以及其有亲缘关系的进程之间
  3. 缓冲区有限
2. FIFO，也称为命名管道，它是一种文件类型。

    1. FIFO可以在无关的进程之间交换数据,与无名管道不同。
    
    2. FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

* 优点：可以实现任意关系的进程间的通信
* 缺点：
  1. 长期存于系统中，使用不当容易出错
  2. 缓冲区有限
  

### 系统IPC：
3. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

特点：

    1. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
    
    2. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
    
    3. 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。


* 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
* 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合

4. 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个线程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

特点：

    1. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
    
    2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
    
    3. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
    
    4. 支持信号量组。


* 优点：可以同步进程
* 缺点：信号量有限

5. 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

6. 套接字（Socket）：
socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

* 优点：
  1. 传输数据为字节级，传输数据可自定义，数据量小效率高
  2. 传输数据时间短，性能高
  3. 适合于客户端和服务器端之间信息实时交互
  4. 可以加密,数据安全性强
* 缺点：需对传输的数据进行解析，转化成应用级的数据。

7. 共享内存（Shared Memory）

它使得多个进程可以访问同一块内存空间（这段共享内存由一个进程创建），不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等
特点：

    1. 共享内存是最快的一种IPC，因为进程是直接对内存进行存取
    
    2. 因为多个进程可以同时操作，所以需要进行同步
    
    3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问


* 优点：无须复制，快捷，信息量大
* 缺点：
  1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
  2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信


# 共享内存为什么可以实现进程通信
共享内存，顾名思义就是允许两个不相关的进程访问同一个逻辑内存，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常为同一段物理内存。进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

**特别提醒**：共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取，所以我们通常需要用其他的机制来同步对共享内存的访问，例如信号量。

在Linux中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。

共享内存的通信原理示意图：
![image](https://pic4.zhimg.com/80/v2-895f5320f774e09f6ccc04a46472efe3_1440w.jpg)
对于上图我的理解是：当两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存，这块内存可以被两个进程同时看到。这样当一个进程进行写操作，另一个进程读操作就可以实现进程间通信。但是，我们要确保一个进程在写的时候不能被读，因此我们使用信号量来实现同步与互斥。对于一个共享内存，实现采用的是引用计数的原理，当进程脱离共享存储区后，计数器减一，挂架成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离。

# 子进程继承了父进程的哪些东西
**子进程继承父进程**：

1. 用户号UID和用户组号GID
2. 环境Environment
3. 堆栈
4. 共享内存
5. 打开文件的描述符
6. 执行时关闭（Close-on-exec）标志
7. 信号（Signal）控制设定
8. 进程组号
9. 当前工作目录
10. 根目录
11. 文件方式创建屏蔽字
12. 资源限制
13. 控制终端
14. 
**子进程独有**:

1. 进程号PID
2. 不同的父进程号
3. 自己的文件描述符和目录流的拷贝
4. 子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）
5. 不继承异步输入和输出

==**父进程和子进程拥有独立的地址空间和PID参数**。==